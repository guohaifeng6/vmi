diff -Nur frameworksAv9/media/libaudioclient/IAudioFlinger.cpp frameworksAv9New/media/libaudioclient/IAudioFlinger.cpp
--- frameworksAv9/media/libaudioclient/IAudioFlinger.cpp	2020-09-23 05:13:36.000000000 -0400
+++ frameworksAv9New/media/libaudioclient/IAudioFlinger.cpp	2020-10-26 21:31:48.180000000 -0400
@@ -88,6 +88,10 @@
     GET_AUDIO_HW_SYNC_FOR_SESSION,
     SYSTEM_READY,
     FRAME_COUNT_HAL,
+    SEND_REMOTE,
+    SEND_REMOTE_SYNC,
+    RECV_REMOTE,
+    CONNECT_REMOTE,
     GET_MICROPHONES,
 };
 
@@ -846,6 +850,51 @@
         }
         return reply.readInt64();
     }
+    virtual status_t sendRemote(int32_t sipc_type, const void *buffer, int size)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(sipc_type);
+        data.writeByteArray(size, (uint8_t *)buffer);
+        remote()->transact(SEND_REMOTE, data, &reply, IBinder::FLAG_ONEWAY);
+        return reply.readInt32();
+    }
+
+    virtual status_t sendRemoteSync(int32_t sipc_type, const void *buffer, int size)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(sipc_type);
+        data.writeByteArray(size, (uint8_t *)buffer);
+        remote()->transact(SEND_REMOTE_SYNC, data, &reply);
+        return reply.readInt32();
+    }
+
+    virtual status_t recvRemote(int32_t sipc_type, void *buffer, int size, bool blocking)
+    {
+        Parcel data, reply;
+        ALOGV("IN recvRemote BpAudioFlinger");
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(sipc_type);
+        data.writeInt32(size);
+        data.writeInt32(blocking);
+        status_t status = remote()->transact(RECV_REMOTE, data, &reply);
+        if (status == NO_ERROR)
+        {
+            int len = reply.readInt32();
+            reply.read((uint8_t *)buffer, len);
+            return len;
+        }
+        return -1;
+    }
+    virtual status_t connectRemote(int32_t sipc_type)
+    {
+        Parcel data, reply;
+        data.writeInterfaceToken(IAudioFlinger::getInterfaceDescriptor());
+        data.writeInt32(sipc_type);
+        remote()->transact(CONNECT_REMOTE, data, &reply);
+        return reply.readInt32();
+    }
     virtual status_t getMicrophones(std::vector<media::MicrophoneInfo> *microphones)
     {
         Parcel data, reply;
@@ -1459,6 +1508,59 @@
             reply->writeInt64( frameCountHAL((audio_io_handle_t) data.readInt32()) );
             return NO_ERROR;
         } break;
+        case SEND_REMOTE_SYNC: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int32_t sipc_type = data.readInt32();
+            int32_t size = data.readInt32();
+            char *buffer = (char *)malloc(size);
+            status_t ret = NO_ERROR;
+            if (buffer == nullptr)
+            {
+                return DEAD_OBJECT;
+            }
+            data.read((uint8_t *)buffer, size);
+            ret = sendRemoteSync(sipc_type, buffer, size);
+            free(buffer);
+            reply->writeInt32(ret);
+            return NO_ERROR;
+        } break;
+        case SEND_REMOTE: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int32_t sipc_type = data.readInt32();
+            int32_t size = data.readInt32();
+            char *buffer = (char *)malloc(size);
+            status_t ret = NO_ERROR;
+            if (buffer == nullptr)
+            {
+                return DEAD_OBJECT;
+            }
+            data.read((uint8_t *)buffer, size);
+            ret = sendRemote(sipc_type, buffer, size);
+            free(buffer);
+            reply->writeInt32(ret);
+            return NO_ERROR;
+        } break;
+        case RECV_REMOTE: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int32_t sipc_type = data.readInt32();
+            int32_t size = data.readInt32();
+            bool blocking = data.readInt32();
+            char *buffer = (char *)malloc(size);
+            if (buffer == nullptr)
+            {
+                return DEAD_OBJECT;
+            }
+            int len = recvRemote(sipc_type, buffer, size, blocking);
+            reply->writeByteArray(len, (uint8_t *)buffer);
+            free(buffer);
+            return NO_ERROR;
+        } break;
+        case CONNECT_REMOTE: {
+            CHECK_INTERFACE(IAudioFlinger, data, reply);
+            int32_t sipc_type = data.readInt32();
+            reply->writeInt32(connectRemote(sipc_type));
+            return NO_ERROR;
+        } break;
         case GET_MICROPHONES: {
             CHECK_INTERFACE(IAudioFlinger, data, reply);
             std::vector<media::MicrophoneInfo> microphones;
diff -Nur frameworksAv9/media/libaudioclient/include/media/IAudioFlinger.h frameworksAv9New/media/libaudioclient/include/media/IAudioFlinger.h
--- frameworksAv9/media/libaudioclient/include/media/IAudioFlinger.h	2020-09-23 05:13:36.000000000 -0400
+++ frameworksAv9New/media/libaudioclient/include/media/IAudioFlinger.h	2020-10-26 21:31:48.180000000 -0400
@@ -41,6 +41,12 @@
 #include "android/media/IAudioRecord.h"
 
 namespace android {
+    // sipc type
+    enum sipc_type
+    {
+        SIPC_AUDIO_TRACK = 0,
+        SIPC_AUDIO_MAX = 1,
+    };
 
 // ----------------------------------------------------------------------------
 
@@ -489,11 +495,22 @@
     // Returns the number of frames per audio HAL buffer.
     virtual size_t frameCountHAL(audio_io_handle_t ioHandle) const = 0;
 
+    // Connect to remote Audio server
+    virtual status_t connectRemote(int32_t sipc_type) = 0;
+
+    // Send msg to remote Audio server
+    virtual status_t sendRemote(int32_t sipc_type, const void *buffer, int size) = 0;
+
+    // Send msg to remote Audio server synchonously
+    virtual status_t sendRemoteSync(int32_t sipc_type, const void *buffer, int size) = 0;
+
+    // Recv msg from remote Audio server
+    virtual status_t recvRemote(int32_t sipc_type, void *buffer, int size, bool blocking) = 0;
+
     /* List available microphones and their characteristics */
     virtual status_t getMicrophones(std::vector<media::MicrophoneInfo> *microphones) = 0;
 };
 
-
 // ----------------------------------------------------------------------------
 
 class BnAudioFlinger : public BnInterface<IAudioFlinger>
diff -Nur frameworksAv9/media/libaudiohal/2.0/DevicesFactoryHalHybrid.cpp frameworksAv9New/media/libaudiohal/2.0/DevicesFactoryHalHybrid.cpp
--- frameworksAv9/media/libaudiohal/2.0/DevicesFactoryHalHybrid.cpp	2020-09-23 05:13:36.000000000 -0400
+++ frameworksAv9New/media/libaudiohal/2.0/DevicesFactoryHalHybrid.cpp	2020-10-26 21:57:48.624000000 -0400
@@ -33,6 +33,7 @@
 
 status_t DevicesFactoryHalHybrid::openDevice(const char *name, sp<DeviceHalInterface> *device) {
     if (mHidlFactory != 0 && strcmp(AUDIO_HARDWARE_MODULE_ID_A2DP, name) != 0 &&
+        strcmp(AUDIO_HARDWARE_MODULE_ID_PRIMARY, name) != 0 &&
         strcmp(AUDIO_HARDWARE_MODULE_ID_HEARING_AID, name) != 0) {
         return mHidlFactory->openDevice(name, device);
     }
diff -Nur frameworksAv9/services/audioflinger/Android.mk frameworksAv9New/services/audioflinger/Android.mk
--- frameworksAv9/services/audioflinger/Android.mk	2020-09-23 05:13:37.000000000 -0400
+++ frameworksAv9New/services/audioflinger/Android.mk	2020-10-26 21:31:48.180000000 -0400
@@ -12,12 +12,13 @@
     libcutils \
     libutils \
     liblog \
-    libbinder
+    libbinder \
+    libVmiCommon
 
 LOCAL_CFLAGS := -Wall -Werror
 
 include $(BUILD_SHARED_LIBRARY)
-
+    
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:=               \
@@ -34,8 +35,16 @@
     TypedLogger.cpp
 
 LOCAL_C_INCLUDES := \
+    $(LOCAL_PATH)/../../include \
+    $(LOCAL_PATH)/../../include/media \
     frameworks/av/services/audiopolicy \
     frameworks/av/services/medialog \
+    external/libopus/include \
+    libsDemo/Common \
+    libs/Common \
+    Cloud/BaseEngine/Audio \
+    CloudDemo/VideoEngine/Libs/include \
+    CloudDemo/InstructionEngine/Libs/include \
     $(call include-path-for, audio-utils)
 
 LOCAL_SHARED_LIBRARIES := \
@@ -56,10 +65,14 @@
     libserviceutility \
     libmediautils \
     libmemunreachable \
-    libmedia_helper
+    libmedia_helper \
+    libIVmiAudio \
+    libDemoCommon \
+    libVmiCommon
 
 LOCAL_STATIC_LIBRARIES := \
     libcpustats \
+    libVmiHWSecure
 
 LOCAL_MULTILIB := $(AUDIOSERVER_MULTILIB)
 
@@ -81,8 +94,6 @@
 
 LOCAL_CFLAGS += -fvisibility=hidden
 
-LOCAL_CFLAGS += -Werror -Wall
-
 include $(BUILD_SHARED_LIBRARY)
 
 include $(call all-makefiles-under,$(LOCAL_PATH))
diff -Nur frameworksAv9/services/audioflinger/AudioFlinger.cpp frameworksAv9New/services/audioflinger/AudioFlinger.cpp
--- frameworksAv9/services/audioflinger/AudioFlinger.cpp	2020-09-23 05:13:37.000000000 -0400
+++ frameworksAv9New/services/audioflinger/AudioFlinger.cpp	2020-10-26 21:31:48.184000000 -0400
@@ -25,6 +25,12 @@
 #include <signal.h>
 #include <sys/time.h>
 #include <sys/resource.h>
+#include <iostream>
+#include <fstream>
+
+#include <sys/socket.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
 
 #include <binder/IPCThreadState.h>
 #include <binder/IServiceManager.h>
@@ -67,7 +73,7 @@
 #include <media/AudioParameter.h>
 #include <mediautils/BatteryNotifier.h>
 #include <private/android_filesystem_config.h>
-
+#include "VmiAudio.h"
 //#define BUFLOG_NDEBUG 0
 #include <BufLog.h>
 
@@ -99,7 +105,10 @@
 nsecs_t AudioFlinger::mStandbyTimeInNsecs = kDefaultStandbyTimeInNsecs;
 
 uint32_t AudioFlinger::mScreenState;
-
+#define AUDIO_SHAREMEM_NAME "audio"
+static const char *sipc_channel_names[] = {
+    AUDIO_SHAREMEM_NAME
+}; // namespace android
 
 #ifdef TEE_SINK
 bool AudioFlinger::mTeeSinkInputEnabled = false;
@@ -230,6 +239,7 @@
 
     mMode = AUDIO_MODE_NORMAL;
 
+    mSipc = nullptr;
     gAudioFlinger = this;
 }
 
@@ -257,6 +267,8 @@
             sMediaLogService->unregisterWriter(iMemory);
         }
     }
+    delete mSipc;
+    mSipc = nullptr;
 }
 
 //static
@@ -2002,9 +2014,175 @@
         ThreadBase *thread = (ThreadBase *)mRecordThreads.valueAt(i).get();
         thread->systemReady();
     }
+    connectRemote(SIPC_AUDIO_TRACK);
+    VmiRegisterAudioHook((void **)&g_audioSendDataHook, (void *)AudiosendRemote);
+    VmiRegisterAudioHook((void **)&g_audioRecvDataHook, (void *)AudioRecvRemote);
     return NO_ERROR;
 }
 
+int AudioFlinger::AudiosendRemote(void *buffer, int size)
+{
+    static sp<IAudioFlinger> af = AudioSystem::get_audio_flinger();
+    return af->sendRemote(SIPC_AUDIO_TRACK, (const void *)buffer, (int32_t)size);
+}
+
+int AudioFlinger::AudioRecvRemote(void *buffer, int size, bool blocking)
+{
+    static sp<IAudioFlinger> af = AudioSystem::get_audio_flinger();
+    return af->recvRemote(SIPC_AUDIO_TRACK, buffer, (int32_t)size, blocking);
+}
+
+int AudioFlinger::RecordsendRemote(const void *buffer, int32_t size)
+{
+    static sp<IAudioFlinger> af = AudioSystem::get_audio_flinger();
+    ALOGD("sendRemote: read buffer=%p size=%d\n", buffer, size);
+    return af->sendRemote(SIPC_AUDIO_MAX, (const void *)buffer, (int32_t)size);
+}
+
+int AudioFlinger::RecordRecvRemote(void *buffer, int size, bool blocking)
+{
+    static sp<IAudioFlinger> af = AudioSystem::get_audio_flinger();
+    ALOGD("recvRemote: read buffe=%p size=%d blocking=%d\n", buffer, size, blocking);
+    return af->recvRemote(SIPC_AUDIO_MAX, buffer, (int32_t)size, blocking);
+}
+
+status_t AudioFlinger::sendRemote(int32_t sipcType, const void *buffer, int32_t size)
+{
+    ALOGD("sendRemote: (%d, %p, %d)\n", sipcType, buffer, size);
+    if (sipcType >= SIPC_AUDIO_MAX || sipcType < 0)
+    {
+        ALOGE("sendRemote: sipc type [%d] invalid.\n", sipcType);
+        return INVALID_OPERATION;
+    }
+
+    if (mSipc == nullptr)
+    {
+        ALOGV("sendRemote: Connection for [%d:%s]has been closed!\n", sipcType, sipc_channel_names[sipcType]);
+        return DEAD_OBJECT;
+    }
+
+    if (buffer == nullptr || size == 0)
+    {
+        ALOGE("sendRemote: buffer is invalid");
+        return NO_ERROR;
+    }
+
+    uint32_t ret = mSipc->WriteFully(VmiBuffer((uint8_t *)buffer, (uint32_t)size));
+
+    ALOGD("sendRemote: sent type [%d] bytes %d\n", sipcType, size);
+    if (ret == 0)
+    {
+        ALOGE("sendRemote: SipcSendMsg data error, ret is %u.\n", ret);
+    }
+
+    return ret;
+}
+
+status_t AudioFlinger::sendRemoteSync(int32_t sipcType, const void *buffer, int32_t size)
+{
+    return sendRemote(sipcType, buffer, size);
+}
+
+status_t AudioFlinger::recvRemote(int32_t sipcType, void *buffer, int32_t size, bool blocking)
+{
+    if (sipcType >= SIPC_AUDIO_MAX || sipcType < 0)
+    {
+        ALOGE("recvRemote: sipc type invalid. sipcType=%d\n", sipcType);
+        return -1;
+    }
+
+    if (mSipc == nullptr)
+    {
+        ALOGV("recvRemote: Connection has been closed! sipcType=%d\n", sipcType);
+        return -1;
+    }
+
+    if (buffer == nullptr)
+    {
+        ALOGE("recvRemote: parameters error. sipcType=%d\n", sipcType);
+        return -1;
+    }
+
+    uint32_t msgSize = 0;
+    do
+    {
+        msgSize = mSipc->ReadSize();
+        if (msgSize < 0)
+        {
+            ALOGE("recvRemote: read error msgSize=%u sipcType=%d\n", msgSize, sipcType);
+            return -1;
+        }
+        if (msgSize)
+        {
+            break;
+        }
+        if (blocking)
+        {
+            usleep(100);
+        }
+    } while (blocking);
+    if (msgSize == 0)
+    {
+        return 0;
+    }
+
+    VmiBuffer vmiBuf((uint8_t *)buffer, msgSize);
+    uint8_t *ret = mSipc->ReadFully(vmiBuf);
+    if (ret == nullptr)
+    {
+        ALOGE("recvRemote: (%d, %p, %d)\n", sipcType, buffer, size);
+        return -1;
+    }
+    char value[PROPERTY_VALUE_MAX];
+    if ((property_get("audio.dbg", value, "0") && (atoi(value) != 0)))
+    {
+        ALOGE("recvRemote: (%d, %p, %d)\n", sipcType, buffer, size);
+    }
+    return msgSize;
+}
+
+status_t AudioFlinger::connectRemote(int32_t sipcType)
+{
+    if (sipcType >= SIPC_AUDIO_MAX || sipcType < 0)
+    {
+        ALOGE("connectRemote: sipc type invalid.\n");
+        return INVALID_OPERATION;
+    }
+
+    if (mSipc != nullptr)
+    {
+        ALOGD("&&&&&&%s: mSpic [%d:%s] is already inited:.\n", __FUNCTION__,
+              sipcType, sipc_channel_names[sipcType]);
+        return NO_ERROR;
+    }
+
+    mSipc = new (std::nothrow) VmiShareMem("audio", 1024 * 16);
+    if (mSipc == nullptr)
+    {
+        ALOGE("%s: Open SipcQueue [%s] failed.\n", __FUNCTION__, sipc_channel_names[sipcType]);
+        return DEAD_OBJECT;
+    }
+
+    if (!mSipc->Open())
+    {
+        ALOGE("error: open audio share mem failed!");
+        delete mSipc;
+        mSipc = nullptr;
+        return -1;
+    }
+
+    if (!mSipc->Ready())
+    {
+        ALOGE("error: audio share mem no ready!");
+        delete mSipc;
+        mSipc = nullptr;
+        return -1;
+    }
+
+    ALOGD("%s: Open SipcQueue [%s] sucess.\n", __FUNCTION__, sipc_channel_names[sipcType]);
+
+    return NO_ERROR;
+}
 status_t AudioFlinger::getMicrophones(std::vector<media::MicrophoneInfo> *microphones)
 {
     AutoMutex lock(mHardwareLock);
diff -Nur frameworksAv9/services/audioflinger/AudioFlinger.h frameworksAv9New/services/audioflinger/AudioFlinger.h
--- frameworksAv9/services/audioflinger/AudioFlinger.h	2020-09-23 05:13:37.000000000 -0400
+++ frameworksAv9New/services/audioflinger/AudioFlinger.h	2020-10-26 21:31:48.184000000 -0400
@@ -74,6 +74,9 @@
 #include "SpdifStreamOut.h"
 #include "AudioHwDevice.h"
 
+// use sipc for communication with vmiagent
+#include "AndroidService/sharemem/VmiShareMem.h"
+
 #include <powermanager/IPowerManager.h>
 
 #include <media/nblog/NBLog.h>
@@ -265,6 +268,19 @@
 
     // end of IAudioFlinger interface
 
+private:
+    virtual status_t connectRemote(int32_t sipc_type);
+    virtual status_t sendRemote(int32_t sipc_type, const void *buffer, int32_t size);
+    virtual status_t sendRemoteSync(int32_t sipc_type, const void *buffer, int32_t size);
+    virtual status_t recvRemote(int32_t sipc_type, void *buffer, int32_t size, bool blocking);
+
+public:
+    static int AudiosendRemote(void *buffer, int size);
+    static int RecordsendRemote(const void *buffer, int32_t size);
+    static int AudioRecvRemote(void *buffer, int size, bool blocking);
+    static int RecordRecvRemote(void *buffer, int size, bool blocking);
+
+public:
     sp<NBLog::Writer>   newWriter_l(size_t size, const char *name);
     void                unregisterWriter(const sp<NBLog::Writer>& writer);
     sp<EffectsFactoryHalInterface> getEffectsFactory();
@@ -849,6 +865,9 @@
     sp<EffectsFactoryHalInterface> mEffectsFactoryHal;
 
     bool        mSystemReady;
+
+    // socket for sendRemote
+    VmiShareMem *mSipc;
 };
 
 #undef INCLUDING_FROM_AUDIOFLINGER_H
diff -Nur frameworksAv9/services/audioflinger/StateQueue.cpp frameworksAv9New/services/audioflinger/StateQueue.cpp
--- frameworksAv9/services/audioflinger/StateQueue.cpp	2020-09-23 05:13:37.000000000 -0400
+++ frameworksAv9New/services/audioflinger/StateQueue.cpp	2020-10-26 21:31:48.184000000 -0400
@@ -187,7 +187,4 @@
 
 }   // namespace android
 
-// hack for gcc
-#ifdef STATE_QUEUE_INSTANTIATIONS
-#include STATE_QUEUE_INSTANTIATIONS
-#endif
+#include "StateQueueInstantiations.cpp"
\ No newline at end of file
